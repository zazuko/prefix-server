apiVersion: v1
data:
  default.vcl: |
    vcl 4.0;
    # tail -f /var/log/syslog
    # import std;
    import bodyaccess;
    backend express {
      .host = "server";
      .port = "80";
      .connect_timeout = 10s;
      .first_byte_timeout = 2m;
      .between_bytes_timeout = 5s;
    }
    sub vcl_recv {
      # Happens before we check if we have this in cache already.
      set req.http.X-Forwarded-Port = "80";
      set req.backend_hint = express;
      # don't cache health endpoint
      if (req.url ~ "^/api/v1/health") {
        return (pass);
      }
      # std.syslog(0, "");
      if (req.restarts == 0) {
        set req.http.x-state = "cache_check";
        # std.syslog(0, "CHECK CACHE");
        return (hash);
      } else if (req.http.x-state == "backend_check") {
        # std.syslog(0, "CHECK BACKEND");
        return (pass);
      } else {
        # std.syslog(0, "RETURN CACHED");
        return (hash);
      }
    }
    sub vcl_hit {
      # std.syslog(0, "HIT");
      if (req.http.x-state == "cache_check") {
        # std.syslog(0, "RESTART");
        set req.http.x-state = "backend_check";
        # apply etag from cache to the request and restart
        set req.http.etag = obj.http.etag;
        return (restart);
      }
    }
    sub vcl_miss {
      # std.syslog(0, "MISS");
    }
    sub vcl_backend_fetch {
      if (bereq.http.x-state == "backend_check") {
        # std.syslog(0, "HEAD");
        set bereq.method = "HEAD";
        set bereq.http.method = "HEAD";
      } else {
        # std.syslog(0, "GET");
      }
    }
    sub vcl_backend_response {
      set beresp.ttl = 1w;
      if (bereq.http.x-state == "backend_check") {
        if (bereq.http.etag != beresp.http.etag) {
          ban("obj.http.etag == " + bereq.http.etag);
          # std.syslog(0, "STALE");
          set beresp.http.x-state = "stale";
        } else {
          # std.syslog(0, "VALID");
          set beresp.http.x-state = "valid";
          return (deliver);
        }
      }
    }
    sub vcl_deliver {
      if (req.http.x-state == "backend_check") {
        if (resp.http.x-state == "stale") {
          set req.http.x-state = "";
          # std.syslog(0, "RESTART BECAUSE STALE");
          return (restart);
        }
        # std.syslog(0, "RESTART WHILE VALID");
        set req.http.x-state = "valid";
        return (restart);
      }
      # std.syslog(0, "FINAL DELIVER");
      # std.syslog(0, "-------------------");
      # std.syslog(0, "");
    }
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: varnish
    app.kubernetes.io/name: prefix-server
  name: varnish-config-8dmdf8m472
  namespace: prefix-server
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: server
    app.kubernetes.io/name: prefix-server
  name: server
  namespace: prefix-server
spec:
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: http
  selector:
    app.kubernetes.io/component: server
    app.kubernetes.io/name: prefix-server
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/component: varnish
    app.kubernetes.io/name: prefix-server
  name: varnish
  namespace: prefix-server
spec:
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: http
  selector:
    app.kubernetes.io/component: varnish
    app.kubernetes.io/name: prefix-server
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: server
    app.kubernetes.io/name: prefix-server
  name: server
  namespace: prefix-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/component: server
      app.kubernetes.io/name: prefix-server
  template:
    metadata:
      labels:
        app.kubernetes.io/component: server
        app.kubernetes.io/name: prefix-server
    spec:
      containers:
      - image: prefix-server
        imagePullPolicy: IfNotPresent
        livenessProbe:
          httpGet:
            path: /api/v1/health
            port: http
        name: prefix-server
        ports:
        - containerPort: 3000
          name: http
          protocol: TCP
        readinessProbe:
          httpGet:
            path: /api/v1/health
            port: http
        resources:
          limits:
            cpu: 100m
            memory: 350Mi
          requests:
            cpu: 50m
            memory: 250Mi
      securityContext:
        runAsGroup: 65534
        runAsUser: 65534
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: varnish
    app.kubernetes.io/name: prefix-server
  name: varnish
  namespace: prefix-server
spec:
  selector:
    matchLabels:
      app.kubernetes.io/component: varnish
      app.kubernetes.io/name: prefix-server
  template:
    metadata:
      labels:
        app.kubernetes.io/component: varnish
        app.kubernetes.io/name: prefix-server
    spec:
      containers:
      - env:
        - name: VCL_CONFIG
          value: /config/default.vcl
        image: docker.io/zazukoians/varnish:5.2.1
        imagePullPolicy: IfNotPresent
        name: prefix-server
        ports:
        - containerPort: 80
          name: http
          protocol: TCP
        resources:
          limits:
            cpu: 50m
            memory: 150Mi
          requests:
            cpu: 25m
            memory: 50Mi
        volumeMounts:
        - mountPath: /config
          name: varnish-config-volume
      volumes:
      - configMap:
          name: varnish-config-8dmdf8m472
        name: varnish-config-volume
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    external-dns.alpha.kubernetes.io/hostname: prefix-zazuko-com.zazukoians.org
    ingress.kubernetes.io/ssl-redirect: "true"
    kubernetes.io/tls-acme: "true"
  labels:
    app.kubernetes.io/name: prefix-server
  name: prefix-server
  namespace: prefix-server
spec:
  rules:
  - host: prefix.zazuko.com
    http:
      paths:
      - backend:
          serviceName: varnish
          servicePort: 80
        path: /
  tls:
  - hosts:
    - prefix.zazuko.com
    secretName: prefix-server-cert
